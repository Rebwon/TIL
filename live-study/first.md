## 1주차 과제: JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가.

참조한 글
[자바명세](https://docs.oracle.com/javase/specs/jls/se11/html/index.html)
[Naver JVM Internal](https://d2.naver.com/helloworld/1230)
[GeeksForGeeks](https://www.geeksforgeeks.org/jvm-works-jvm-architecture/)

## Table of contents

- JVM이란 무엇인가
- 컴파일 하는 방법
- 실행하는 방법
- 바이트코드란 무엇인가
- JVM 구성 요소(JIT 컴파일러 포함)
- JDK와 JRE의 차이

### JVM이란 무엇인가

JVM(Java Virtual Machine)은 Java 애플리케이션을 실행하는 런타임 엔진 역할을 합니다. JVM은 자바 코드에 있는 주요 메소드를 호출합니다. JVM은 JRE(Java Runtime Env)의 일부입니다.

개발자가 작성한 .java 파일을 컴파일할 때 .java 파일에 동일한 클래스 이름을 가진 .class 파일(바이트 코드 포함)이 Java 컴파일러에 의해 생성됩니다. 

JVM의 특징은 다음과 같습니다.
- 스택 기반의 가상 머신: 대표적인 컴퓨터 아키텍처인 인텔 x86 아키텍처나 ARM 아키텍처와 같은 하드웨어가 레지스터 기반으로 동작하는 데 비해 JVM은 스택 기반으로 동작한다.
- 심볼릭 레퍼런스: 기본 자료형(primitive data type)을 제외한 모든 타입(클래스와 인터페이스)을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심볼릭 레퍼런스를 통해 참조한다.
- 가비지 컬렉션(garbage collection): 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴된다.
- 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장: C/C++ 등의 전통적인 언어는 플랫폼에 따라 int 형의 크기가 변한다. JVM은 기본 자료형을 명확하게 정의하여 호환성을 유지하고 플랫폼 독립성을 보장한다.
- 네트워크 바이트 오더(network byte order): 자바 클래스 파일은 네트워크 바이트 오더를 사용한다. 인텔 x86 아키텍처가 사용하는 리틀 엔디안이나, RISC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송 시에 사용하는 바이트 오더인 네트워크 바이트 오더를 사용한다. 네트워크 바이트 오더는 빅 엔디안이다.

### 컴파일 하는 방법

javac 파일명.java로 컴파일이 가능합니다.

자바 코드를 컴파일하면 컴파일 단계에서 문법적 오류를 검증합니다. 이때 컴파일된 코드는 바이트코드라고 합니다.

### 실행하는 방법

java 패키지명.클래스로 실행합니다. 

실행 옵션
- cp: classpath를 지정
- sourcepath: 컴파일 하기 위해 필요로 하는 참조할 소스파일의 위치 지정
- d: 클래스 파일을 생성할 루트 디렉터리 지정
- encoding: 소스 파일 인코딩 설정
- g: 디버깅 정보 생성
- nowarn: 경고 메세지 생성하지 않음
- verbose: 컴파일러와 링커가 현재 어느 소스파일이 컴파일 되고 있고, 어느 파일이 링크되고 있는지 정보를 출력
- target: 지정된 자바 버전의 JVM에서 작동되도록 .class 파일을 생성

### 바이트 코드란?

바이트 코드는 JVM 언어들을 컴파일한 결과로 나오는 코드로써 JVM이 읽어서 기계어로 번역할 수 있는 코드입니다.

### JIT 컴파일러

### JVM 구성 요소

- ClassLoader
- Execution Engine
- Runtime Data area

#### ClassLoader

ClassLoader는 Class를 로드하는 개체입니다. ClassLoader는 추상 클래스입니다. 클래스의 이진 이름(Ex: java.lang.String, javax.swing.JSpinner$DefaultEditor)이 지정되면 ClassLoader는 클래스에 대한 정의를 구성하는 데이터를 찾거나 생성해야 합니다. 일반적인 전략은 이름을 파일 이름으로 변환한 다음, 파일 시스템에서 해당 이름의 .class 파일을 읽는 것입니다. 모든 클래스 개체에는 해당 개체를 정의한 ClassLoader에 대한 참조가 포함되어 있습니다.

배열 클래스의 클래스 개체는 클래스 로더에 의해 생성되지 않고 Java 런타임에 필요한 대로 자동으로 생성됩니다. Class.getClassLoader()에서 반환되는 배열 클래스의 클래스 로더는 해당 요소 유형에 대한 클래스 로더와 동일합니다. 요소 유형이 원시(primitive) 유형이면 배열 클래스에 클래스 로더가 없습니다.

애플리케이션은 JVM이 클래스를 동적으로 로드하는 방식을 확장하기 위해 ClassLoader의 하위 클래스를 구현합니다.

클래스 로더는 일반적으로 보안 관리자가 보안 도메인을 나타내는 데 사용할 수 있습니다. 클래스 로더는 클래스를 로드하는 것 외에 리소스를 찾는 작업도 담당합니다.

ClassLoader 클래스는 위임 모델을 사용하여 클래스 및 리소스를 탐색합니다. ClassLoader의 각 인스턴스에는 연결된 부모 클래스 로더가 있습니다. 클래스 또는 리소스를 찾도록 요청할 경우 ClassLoader 인스턴스는 클래스 또는 리소스 자체를 찾기 전에 일반적으로 클래스 또는 리소스에 대한 검색을 부모 클래스 로더에 위임합니다.

클래스의 동시 로드를 지원하는 클래스 로더는 병렬 지원 클래스 로더라고 하며 ClassLoader.registerAsParallelCapable 메서드를 호출하여 클래스 초기화 시간에 자체 등록해야 합니다. ClassLoader 클래스는 기본적으로 병렬 가능 클래스로 등록됩니다. 그러나 병렬로 사용할 수 있는 경우 하위 클래스는 여전히 자체 등록이 필요합니다. 위임 모델이 엄격히 계층적이지 않은 환경에서는 클래스 로더가 병렬로 작동할 수 있어야 합니다. 그렇지 않으면 클래스 로딩 프로세스 기간 동안 로더 잠금이 유지되기 때문에 클래스 로더가 교착 상태로 이어질 수 있습니다(loadClass 방법 참조).

런타임시 기본 제공하는 클래스 로더는 다음과 같습니다.
- BootStrapClassLoader: 부트스트랩 클래스로더는 전문적으로 말해서 클래스로더가 아닙니다. 왜냐하면 부트스트랩 클래스로더는 JVM의 네이티브 코드 영역에 존재하며, Object와 같은 코어 자바 클래스를 VM에 로딩할 때 사용되기 때문입니다. 
- PlatformClassLoader: 모든 플랫폼 클래스는 ClassLoader 인스턴스의 부모로 사용할 수 있는 플랫폼 클래스 로더에 표시됩니다. 플랫폼 클래스에는 Java SE 플랫폼 API, 해당 구현 클래스 및 플랫폼 클래스 로더 또는 그 상위 항목에 의해 정의된 JDK별 런타임 클래스가 포함됩니다. 플랫폼 클래스 로더에 정의된 모듈의 업그레이드/오버라이드를 허용하고 업그레이드된 모듈이 플랫폼 클래스 로더 및 그 상위 로더가 아닌 클래스 로더에 정의된 모듈을 읽는 경우 플랫폼 클래스 로더는 예를 들어 애플리케이션 클래스 로더인 다른 클래스 로더에 위임해야 할 수 있습니다. 즉, 플랫폼 클래스 로더 및 그 상위 로더가 아닌 클래스 로더에 정의된 명명된 모듈의 클래스가 플랫폼 클래스 로더에 표시될 수 있습니다.
- SystemClassLoader: 애플리케이션 클래스 로더라고도 하며 플랫폼 클래스 로더와 구별됩니다. 시스템 클래스 로더는 일반적으로 애플리케이션 클래스 경로, 모듈 경로 및 JDK 관련 도구에 대한 클래스를 정의하는 데 사용됩니다. 플랫폼 클래스 로더는 모든 플랫폼 클래스가 표시되는 시스템 클래스 로더의 상위 또는 상위 항목입니다.

클래스로더 동작에는 3가지 원칙이 존재합니다.
- 위임 원칙: 클래스로딩 작업을 상위 클래스로더에 위임한다.
- 가시 범위 원칙: 하위 클래스로더는 상위 클래스로더가 로딩한 클래스를 볼 수 있지만, 상위 클래스로더는 하위 클래스로더가 로딩한 클래스를 볼 수 없다.
- 유일성 원칙: 하위 클래스로더는 상위 클래스로더가 로딩한 클래스를 다시 로딩하지 않게 해서 로딩된 클래스의 유일성을 보장한다.

클래스로더의 로드 방식에는 2가지가 존재합니다.
- 런타임 동적 로딩
- 로드타임 동적 로딩

```java
public class Test implements Runnable {
     public void run() {
        System.out.println("Test");
     }
  }
public class RuntimeLoading {
    public static void main(String[] args) {
        try {
           if (args.length < 1) {
              System.exit(1);
           }
           Class t = Class.forName(args[0]);
           Object obj = t.newInstance();
           Runnable r = (Runnable) obj;
           r.run();
        } catch(Exception ex) {
            ex.printStackTrace();
        }
    }
}
```

런타입 로딩은 클래스를 로딩하는 시점이 아닌 코드를 실행하는 순간에 클래스를 로딩하는 기법입니다. java RuntimeLoading test 라는 CommandLine를 통해서 위의 클래스를 실행하게되면 Class.forName()메서드에 의해서 Class객체 인스턴스가 반환됩니다.

그리고, newInstance() 메서드를 호출함으로써 Test객체의 인스턴스가 반환이 됩니다. 즉, RuntimeLoading클래스를 로딩할 때는 어떤 클래스도 읽어오지 않고, Class.forName()을 호출하는 순간에 클래스 파일 이름에 해당하는 클래스를 로드하게 됩니다. 


```java
public class LoadTimeLoading {
    public static void main(String[] args) {
        System.out.println("LoadTimeLoading test");
    }
}
```

로드타임 로딩 기법은 하나의 클래스를 로딩하는 과정에서 동적으로 클래스를 로딩하는 방법을 의미합니다. LoadTimeLoading클래스를 위와같이 작성하고 java LoadTimeLoading CommandLine으로 실행을 하면 JVM이 시작되고, 부트스트랩 클래스로더가 생성된 후에 모든 클래스가 상속받고 있는 Object클래스를 읽어옵니다.

그리고, 클래스 로더에서는 명령행에서 지정한 LoadTimeLoading.class파일을 읽습니다. 이때, LoadTimeLoading 클래스에서는 java.lang.System, java.lang.String 클래스를 사용하고 있습니다. 즉, LoadTimeLoading클래스를 로딩하는 시점에서 동적으로 필요한 클래스를 로딩하는 기법입니다.

자바에서 클래스의 이름은 클래스 이름 공간이라는 개념으로 처리되고, 클래스 이름 공간은 다음의 형태로 구성됩니다.

(패키지,이름,클래스로더)

따라서, 제 아무리 같은 클래스라도 클래스로더가 다르면, JVM 내에서 다른 클래스로 처리됩니다.

마지막으로 ClassLoader는 다음의 동작들을 진행합니다.
- Loading
- Linking
- Initialization

각 단계를 설명하면 다음과 같습니다.

- 로드: 클래스를 파일에서 가져와서 JVM의 메모리에 로드한다.
- 검증(Verifying): 읽어 들인 클래스가 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 잘 구성되어 있는지 검사한다. 클래스 로드의 전 과정 중에서 가장 까다로운 검사를 수행하는 과정으로서 가장 복잡하고 시간이 많이 걸린다. JVM TCK의 테스트 케이스 중에서 가장 많은 부분이 잘못된 클래스를 로드하여 정상적으로 검증 오류를 발생시키는지 테스트하는 부분이다.
- 준비(Preparing): 클래스가 필요로 하는 메모리를 할당하고, 클래스에서 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조를 준비한다.
- 분석(Resolving): 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.
- 초기화: 클래스 변수들을 적절한 값으로 초기화한다. 즉, static initializer들을 수행하고, static 필드들을 설정된 값으로 초기화한다.


#### Execution Engine

Execution Engine은 JVM의 중앙 구성 요소입니다. JVM의 다양한 Memory Area와 통신합니다. 실행중인 애플리케이션의 각 스레드는 JVM Execution Engine의 개별 인스턴스입니다. Execution Engine은 클래스 로더를 통해 JVM의 Runtime Data Area에 할당된 바이트 코드를 실행합니다. Java 클래스 파일은 실행 엔진에 의해 실행됩니다.

Execution Engine에는 Java 클래스를 실행하기 위한 세 가지 주요 구성 요소가 있습니다.

- 인터프리터: 바이트 코드를 읽고 기계어 코드 (네이티브 코드)로 해석(변환)하여 순차적으로 실행합니다. 이 구성 요소는 파일 이름 인수를 허용하여 CommandLine에서 응용 프로그램을 실행합니다. 인터프리터의 문제는 매번 동일한 방법을 여러 번 해석하여 시스템 성능을 저하 시킨다는 것입니다. 이 문제를 극복하기 위해 JIT 컴파일러는 1.1 버전에 도입되었습니다.
- JIT 컴파일러: JIT 컴파일러는 느린 실행이라는 인터프리터의 단점을 보완하고 성능을 향상시킵니다.
런타임에 JVM은 클래스 파일을 로드하고 각각의 의미가 결정되고 적절한 계산이 수행됩니다. 해석 중 추가 프로세서 및 메모리 사용으로 인해 Java 응용 프로그램이 기본 응용 프로그램에 비해 느리게 수행됩니다.
JIT 컴파일러는 런타임에 바이트 코드를 원시 기계 코드로 컴파일하여 Java 프로그램의 성능을 향상시키는 데 도움을줍니다.
JIT 컴파일러는 메서드가 호출될 때 활성화되는 동안 전체적으로 활성화됩니다. 컴파일 된 메서드의 경우 JVM은 컴파일 된 코드를 해석하는 대신 직접 호출합니다. 이론적으로 말하면 컴파일에 프로세서 시간이나 메모리 사용이 필요하지 않다면 네이티브 컴파일러와 Java 컴파일러의 속도는 동일했을 것입니다.
JIT 컴파일에는 프로세서 시간과 메모리 사용량이 필요합니다. Java 가상 머신이 처음 시작되면 수천 개의 메소드가 호출됩니다. 이러한 모든 메서드를 컴파일하면 최종 결과가 성능 최적화가 매우 우수하더라도 시작 시간에 상당한 영향을 미칠 수 있습니다.
  - 프로파일러: JIT 컴파일러의 일부인 도구로 JVM 수준에서 Java 바이트 코드 구성 및 작업을 모니터링합니다.
- Garbage Collector: 메모리를 자동으로 관리하는 자바 프로그램입니다. GC는 데몬 스레드이며 항상 백그라운드에서 실행됩니다. 이것은 기본적으로 연결할 수 없는 메소드를 파괴하여 힙 메모리를 확보합니다.

#### Runtime Data Area

런타임 데이터 영역은 JVM이라는 프로그램이 운영체제 위에서 실행되면서 할당받는 메모리 영역입니다. 런타임 데이터 영역은 6개의 영역으로 나눌 수 있습니다. 이중 PC 레지스터(PC Register), JVM 스택(JVM Stack), 네이티브 메서드 스택(Native Method Stack)은 스레드마다 하나씩 생성되며 힙(Heap), 메서드 영역(Method Area), 런타임 상수 풀(Runtime Constant Pool)은 모든 스레드가 공유해서 사용합니다.

- PC 레지스터: PC(Program Counter) 레지스터는 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. PC 레지스터는 현재 수행 중인 JVM 명령의 주소를 갖는다.
- JVM 스택: JVM 스택은 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. 스택 프레임(Stack Frame)이라는 구조체를 저장하는 스택으로, JVM은 오직 JVM 스택에 스택 프레임을 추가하고(push) 제거하는(pop) 동작만 수행한다. 예외 발생 시 printStackTrace() 등의 메서드로 보여주는 Stack Trace의 각 라인은 하나의 스택 프레임을 표현한다.
- 스택 프레임: JVM 내에서 메서드가 수행될 때마다 하나의 스택 프레임이 생성되어 해당 스레드의 JVM 스택에 추가되고 메서드가 종료되면 스택 프레임이 제거된다. 각 스택 프레임은 지역 변수 배열(Local Variable Array), 피연산자 스택(Operand Stack), 현재 실행 중인 메서드가 속한 클래스의 런타임 상수 풀에 대한 레퍼런스를 갖는다. 지역 변수 배열, 피연산자 스택의 크기는 컴파일 시에 결정되기 때문에 스택 프레임의 크기도 메서드에 따라 크기가 고정된다.
- 지역 변수 배열: 0부터 시작하는 인덱스를 가진 배열이다. 0은 메서드가 속한 클래스 인스턴스의 this 레퍼런스이고, 1부터는 메서드에 전달된 파라미터들이 저장되며, 메서드 파라미터 이후에는 메서드의 지역 변수들이 저장된다.
- 피연산자 스택: 메서드의 실제 작업 공간이다. 각 메서드는 피연산자 스택과 지역 변수 배열 사이에서 데이터를 교환하고, 다른 메서드 호출 결과를 추가하거나(push) 꺼낸다(pop). 피연산자 스택 공간이 얼마나 필요한지는 컴파일할 때 결정할 수 있으므로, 피연산자 스택의 크기도 컴파일 시에 결정된다.
- 네이티브 메서드 스택: 자바 외의 언어로 작성된 네이티브 코드를 위한 스택이다. 즉, JNI(Java Native Interface)를 통해 호출하는 C/C++ 등의 코드를 수행하기 위한 스택으로, 언어에 맞게 C 스택이나 C++ 스택이 생성된다.
- 메서드 영역: 메서드 영역은 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 정보, Static 변수, 메서드의 바이트코드 등을 보관한다. 메서드 영역은 JVM 벤더마다 다양한 형태로 구현할 수 있으며, 오라클 핫스팟 JVM(HotSpot JVM)에서는 흔히 Permanent Area, 혹은 Permanent Generation(PermGen)이라고 불린다. 메서드 영역에 대한 가비지 컬렉션은 JVM 벤더의 선택 사항이다.
- 런타임 상수 풀: 클래스 파일 포맷에서 constant_pool 테이블에 해당하는 영역이다. 메서드 영역에 포함되는 영역이긴 하지만, JVM 동작에서 가장 핵심적인 역할을 수행하는 곳이기 때문에 JVM 명세에서도 따로 중요하게 기술한다. 각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. 즉, 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다.
- 힙: 인스턴스 또는 객체를 저장하는 공간으로 가비지 컬렉션 대상이다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이다. 힙 구성 방식이나 가비지 컬렉션 방법 등은 JVM 벤더의 재량이다.

### JDK와 JRE의 차이

- JDK는 자바 개발 도구
- JRE는 자바 실행 환경

자바 애플리케이션을 개발하려면 JDK가 필요하고, 단순히 실행만 하려면 JRE만 있으면 됩니다.
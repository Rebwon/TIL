## DDD 구현 기초 정리

출처 : https://www.slideshare.net/madvirus/ddd-final

### 클래스 : 객체의 정의

- 기능(메세징)을 public 메서드로 정의
  - 데이터는 외부에 드러내지 않고 기능 정의만 제공.
    - getter/setter 메서드 최소화

- 다른 객체를 사용하는 방법
  - 필드를 이용해서 다른 객체를 레퍼런스로 참조
    - 연관(Association)이라고 표현
  - 메서드에서 필요한 시점에 객체를 생성해서 사용
  
객체 간 연관의 예
```java
public class Employee{
    private String name;
    private Organization organization;
    
    public void setOrganization(Organization org) {
        this.organization = org;
    }   
}

public class Organization{
    private String name;
    private List<Employee> employees;
    
    public void add(Employee emp){
        this.employees.add(emp);
        emp.setOrganization(this);
    }
}

Organization org = new Organization();

Employee e1 = new Employee();
Employee e2 = new Employee();

org.add(e1);
org.add(e2);
```

### 연관의 방향성

- 방향성의 종류
  - 단방향: 두 객체 중 한 객체만 레퍼런스 가짐
  - 양방향: 두 객체가 서로에 대한 레퍼런스 가짐

### 연관의 종류

- ManyToOne
  - 예, 다수의 Employee가 한 Organization과 연관
- OneToMany
  - 예, 한 Organization이 다수의 Employee와 연관
  - 콜렉션으로 구현: Set, List, Map
- OneToOne
  - 예, 한 Organization이 한 Rule과 연관
- ManyToMany
  - 콜렉션
  
### 모든 객체가 메모리 있다면... (1)

- 연관된 객체들을 이용해서 기능을 구현
- 예1) Rule의 교체: 연관된 객체 교환으로 구현

```java
Organization org = ..; // 어딘가에서 구함(JPA)
Rule newRule = new Rule();
org.changeRule(newRule);

// Organization의 메서드
public void changeRule(Rule newRule){
    this.rule = newRule;
}
```

- 예2) 팀 이동: 양방향 연관을 처리
```java
Organization org = ..; // 어딘가에서 구함(JPA)
Employee emp1 = ..; // 어딘가에서 구함(JPA)
emp1.trasferTo(org);

// Employee의 메서드
public void transferTo(Organization org){
    Organization oldOrg = this.organization;
    this.organization = org;
    oldOrg.remove(this);
}

// Organization의 메서드
public void remove(Employee e){
    employees.remove(e);
}
```

### 모든 객체가 메모리 있다면.. (2)

- 연관된 객체들을 이용해서 기능을 구현
- 예3) Rule의 확인: 연관된 객체를 구해 확인

```java
Organization org = ..; // 어딘가에서 구함(JPA)
Rule rule = org.getRule();
if(rule != null){
    rule.check(someData);
}

// Organization의 메서드
public Rule getRule(){
    return this.rule;
}

// Rule의 메서드
public void check(Data data) {...}
```

- 예4) Rule의 확인: 내부적으로 위임
```java
Organization org = ..; // 어딘가에서 구함(JPA)
org.checkRule(someData);

// Organization의 메서드
public void checkRule(Data data){
    if(rule == null){
        return;
    }   
    rule.check(data);
}
```

### 모든 객체가 메모리 있다면.. (3)

- 객체를 메모리에 보관/검색 위한 방법 필요
  - 객체마다 고유 식별값 필요
    - 메모리 상의 레퍼런스 이용은 한계
    - 고유 식별 값을 갖는 객체를 Entity라 함.
  - 객체 보관하고 제공해주는 기능 필요
    - DDD에서는 이를 Repository로 추상화
    
### 객체의 라이프사이클

- 객체 생성 - 사용 - 소멸
  - 동일 라이프사이클을 갖는 객체들의 군집 존재
  - 동일 라이프사이클 == 한 트랜잭션 단위

### 도메인 모델의 기본 구성 요소

- Entity
- Value
- Aggregate
- Repository
- Service

### 도메인 모델의 기본 구성 요소, Entity

- 주요 특징
  - 모델을 표현
  - 고유의 식별 값을 가짐
  - 모델과 관련된 비즈니스 로직을 수행
  - 자신만의 라이프 사이클을 가짐
- 예, 평가 시스템에서의 Entity
  - Employee
  - Organization
  
### 도메인 모델의 기본 구성 요소, Value

- 고유의 키 값을 갖지 않음
- 데이터를 표현하기 위한 용도로 주로 사용
  - 개념적으로 완전한 데이터 집합
  - (주로) 불변임
  - 자신에게 알맞은 로직을 제공
  - Entity의 속성으로 사용
    - 자신의 라이프사이클을 갖지 않음
    - 엔티티를 따름
- 예
  - Address(주소)
    - 데이터: 우편번호, 주소1, 주소2
  - Money(돈)
    - 데이터: 금액, 화폐 단위
    - 로직: 더하기, 곱하기 등

### 도메인 모델의 기본 구성 요소, Aggregate

- Aggregate
  - 관련된 객체들의 묶음
- Aggregate의 특징
  - 데이터 변경 시 한 단위로 처리됨
    - 비슷한 또는 거의 유사한 라이플사이클을 갖는 객체들
      - 특히, 삭제 시 함께 삭제됨
  - Aggregate은 경계를 가짐
    - 기본적으로, 한 Aggregate에 속한 객체는 다른 Aggregate에 속하지 않음.

- Aggregate의 필요성
  - 많은 도메인 모델을 가능한 간단하고 이해가능한 수준으로 만들 필요
  - 연관의 개수를 줄임으로써 복잡도 감소
  
### 도메인 모델의 기본 구성 요소, Aggregate 루트

- Aggregate은 루트를 가짐
- Aggregate 루트 역할
  - Aggregate의 내부 객체들을 관리
  - Aggregate 외부에서 접근할 수 있는 유일한 객체
    - Aggregate의 내부 Entity/Value는 루트를 통해 접근
  - Aggregate에 대한 알맞은 기능을 수행
    - 예) 주문 관련 Aggregate 루트인 Order의 기능
      - 주문 취소, 배송지 주소 변경, 주문 상품 변경
    - 내부 객체들의 연관을 탐색해서 기능 구현
    
### 레이어 아키텍처

엔터프라이즈 애플리케이션을 설계할 때, 주로 우리는 레이어 아키텍처를 많이 사용한다.
레이어 아키텍처의 전형적인 영역이 '표현', '응용', '도메인', '인프라스트럭처'의 네 영역이다.

도메인 주도 설계에서 표현 영역을 통해 사용자의 요청을 전달받는 응용 영역은 시스템이 사용자에게 제공해야할 기능을 구현한다.

응용 영역은 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다. 주문 취소 기능을 제공하는 응용 서비스를 예로 들면
다음과 같이 주문 도메인 모델을 사용해서 기능을 구현한다.

```java
public class CancelOrderService{
    @Transactioanl
    public void cancelOrder(Long orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new IllegalArgumentException("No Order"));
        order.cancel();
    }
}
```

응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 *위임*한다. 위 코드도 주문 취소 로직을 직접 구현하지 않고
Order 객체에 취소 처리를 위임하고 있다.

도메인 영역은 도메인 모델을 구현한다. 도메인 모델은 도메인의 핵심 *로직*을 구현한다. 주문 도메인의 경우 '배송지 변경', '결제 완료', '주문 총액 계산'과 같은
핵심 로직을 도메인 모델에서 구현한다.

인프라스트럭처 영역은 구현 기술에 대한 것을 다룬다. 이 영역은 RDBMS 연동을 처리하고, 메시징 큐에 메시지를 전송하거나 수신하는 기능을 구현하고, SMTP를 통해 메일 발송
기능을 구현하거나 REST API 호출하는 것도 처리한다.

인프라스트럭처 영역은 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.

레이어 아키텍처에서는 상위 계층에서 하위 계층으로의 의존만 존재하고, 하위 계층은 상위 계층에 의존하지 않는다.
예를 들어, 표현 계층은 응용 계층에 의존하고 응용 계층이 도메인 계층에 의존하지만, 반대로 인프라스트럭처 계층이 도메인에 의존하거나 도메인이 응용 계층에 의존하지 않는다.

레이어 아키텍처를 엄격하게 적용하면 상위 계층은 바로 아래의 계층에만 의존을 가져야 하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용한다. 예를 들어, 응용 계층은
바로 아래 계층인 도메인 계층에 의존하지만 외부 시스템과의 연동을 위해 더 아래 계층인 인프라스트럭처 계층에 의존하기도 한다.

의존성의 방향이 위에서 아래로 흐르는 것이 맞지만, 이럴 경우 상위계층인(표현, 응용, 도메인) 계층이 인프라스트럭처 계층에 종속되게 된다.

모든 계층이 인프라스트럭처 계층에 의존하면 '테스트 어려움'과 '기능 확장의 어려움'이라는 두 가지 문제가 발생하는 것을 알았다.

이러한 문제를 해결하는 것은 DIP를 적용하는 것이다.

### DIP

고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 그런데, 고수준 모듈이 저수준 모듈을 사용하면 앞서 계층 구조 아키텍처에서 언급했던 두 가지 문제(구현 변경과 테스트가 어려움)가 발생한다.

DIP는 이 문제를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다. 고수준 모듈을 구현하려면 저수준 모듈을 사용해야 하는데, 반대로 저수준 모듈이 고수준 모듈에
의존하도록 하려면 어떻게 해야 할까? 비밀은 추상화한 인터페이스에 있다.

DIP를 적용할 때 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출한다. 

### 모듈 구성

기본적으로 레이어 아키텍처에 맞게 패키지를 구성한다.

도메인이 크면 각 도메인 안에 레이어 아키텍처에 맞게 패키지를 구성한다.

### 에그리거트 별 트랜잭션 범위

에그리거트 별로 별도의 트랜잭션으로 관리하되, 한 에그리거트가 다른 에그리거트를 수정해서는 안된다. 그렇게 하게되면 모듈간 의존성을 높이기 때문에
권장하지 않는다. 대신, 응용 서비스 영역에서 서로 다른 에그리거트 두개를 수정하는 것이 바람직하다.

한 트래잭션에서 한 개의 에그리거트를 변경하는 것을 권장하지만, 다음의 경우에는 한 트랜잭션에서 두 개 이상의 에그리거트를 변경하는 것을 고려할 수 있다.

- 팀 표준: 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우가 있다. DB가 다른 경우 글로벌 트랜잭션을 반드시
사용하도록 규칙을 정하는 곳도 있다.
- 기술 제약: 한 트랜잭션에서 두 개 이상의 에그리거트를 수정하는 대신 도메인 이벤트와 비동기를 사용하는 방식을 사용하는데, 기술적으로 이벤트 방식을 도입할 수 없는 경우 한
트랜잭션에서 다수의 에그리거트를 수정해서 일관성을 처리해야한다.
- UI 구현의 편리: 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 것이다. 이 경우 한 트랜잭션에서 여러 주문 에그리거트의 상태를 변경할 수 있을 것이다.

### 에그리거트와 리포지터리

에그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로, 객체의 영속성을 처리하는 리포지터리는 에그리거트 단위로 존재한다. 

### 도메인 서비스

할인 계산 규칙처럼 한 에그리거트에 넣기 어려운 도메인 개념을 구현하려면 에그리거트에 억지로 넣기보다는
도메인 서비스를 이용해서 도메인 개념을 명시적으로 드러내면 된다.

응용 영역의 서비스가 응용 로직을 다룬다면 도메인 서비스는 도메인 로직을 다룬다.

도메인 서비스가 도메인 영역의 에그리거트나 밸류와 같은 다른 구성요소와 비교할 때 다른 점이 있다면 상태 없이 로직만 구현한다는 점이다.
도메인 서비스를 구현하는 데 필요한 상태는 에그리거트나 다른 방법으로 전달받는다.

에그리거트 객체에 도메인 서비스를 전달하는 것은 응용 서비스의 책임이다.

도메인 서비스의 위치는 도메인 패키지 안에 넣는 게 좋다.

특정 기능이 응용 서비스인지 도메인 서비스인지 감을 잡기 어려울 때는 해당 로직이 에그리거트의 상태를 변경하거나 에그리거트의 상태 값을
계산하는지 검사해 보면 된다. 

### 바운디드 컨텍스트

바운디드 컨텍스트가 필요한 예는 다음과 같다.

예를 들어, 상품이라는 모델을 생각해보자. 카탈로그에서의 상품, 재고 관리에서의 상품, 주문에서의 상품, 배송에서의 상품은 이름만 같지
실제로 의미하는 것이 다르다. 카탈로그에서의 상품은 상품명, 상품이미지, 상품 옵션, 상품 설명, 상품 가격 등과 같은 단일 상품 한 건에 대한 정보가 위주라면,
재고 관리에서의 상품은 실존하는 개별 객체를 추적하기 위한 목적으로 상품을 사용한다. 즉, 카탈로그에서 물리적으로 한 개인 상품이 재고 관리에서는 여러 개 존재할 수 있다.

논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어로 사용하는 경우도 있다. 카탈로그 도메인에서 상품이 검색 도메인에서는 문서로 불리기도 한다. 비슷하게
시스템을 사용하는 사람을 회원 도메인에서는 회원이라 부르지만, 주문 도메인에서는 주문자라고 부르고, 배송 도메인에서는 보내는 사람이라 부르기도 한다.

이렇게 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며,
표현할 수도 없다.

하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야 한다. 각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야 한다.
여러 하위 도메인의 모델이 섞이기 시작하면 모델의 의미가 약해질 뿐만 아니라 여러 도메인의 모델이 서로 얽혀 있기 때문에 각 하위 도메인 별로 다르게 발전하는 요구사항을 모델에 반영하기가 어려워진다.

모델은 특정한 컨텍스트(문맥)하에서 완전한 의미를 갖는다. 같은 제품이라도 카탈로그 컨텍스트와 재고 컨텍스트에서 의미가 서로 다르다. 이렇게 구분되는 경계를
갖는 컨텍스트를 DDD에서는 바운디드 컨텍스트라 부른다.

여러 하위 도메인(주문, 상품, 회원)을 하나의 바운디드 컨텍스트(온라인 쇼핑몰)에서 개발할 때 주의할 점은 하위 도메인의 모델이 뒤섞이지 않도록 하는 것이다. 
한 개의 바운디드 컨텍스트에서 여러 하위 도메인을 포함하더라도 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 하위 도메인을 위한 모델이 서로 섞이지 않아서 하위 도메인마다 
바운디드 컨텍스트를 갖는 효과를 낼 수 있다.

바운디드 컨텍스트가 도메인 모델만 포함하는 것은 아니다. 바운디드 컨텍스트는 도메인 모델뿐만 아니라 도메인 기능을 사용자에게 제공하는 데 필요한 표현 영역,
응용 서비스, 인프라 영역 등을 모두 포함한다. 도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야 하므로 해당 테이블도 바운디드 컨텍스트 안에 포함된다.

단, 모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다. 상품의 리뷰는 복잡한 도메인 로직을 갖지 않기 때문에 단순한 CRUD 방식으로 구현해도 된다. 즉, DAO와 데이터 중심의
밸류 객체를 이용해서 리뷰 기능을 구현해도 기능을 유지보수하는 데 큰 문제가 없다.

서비스-DAO 구조를 사용하면 도메인 기능이 서비스에 흩어지게 되지만 도메인 기능 자체가 단순하면 서비스-DAO로 구성된 CRUD 방식을 사용해도 코드를 유지보수 하는데 문제되지 않는다.

또한 바운디드 컨텍스트는 UI를 가지지 않아도 상관 없다. RestAPI를 통해서 JSON 응답을 보내줘도 된다. 추가로 UI 서버를 브라우저와 바운디드 컨텍스트 사이에 두고
사용자 요청을 처리하는 방법도 있다.

UI서버를 통해 브라우저와 바운디드 컨텍스트 간에 파사드 역할을 담당하고, 각 바운디드 컨텍스트는 UI 서버와 통신하기 위해 HTTP, Protobuf, Thrift와 같은 방식을
이용할 수 있을 것이다.

### 바운디드 컨텍스트 통합

바운디드 컨텍스트 간 통합을 위해서는 도메인 서비스를 정의하고 인프라 영역에 외부 모듈 간 모델 변환 처리를 담당할 클래스를 만들어서 
각 바운디드 컨텍스트가 통신할 때 주고 받는 응답을 변환하는 역할을 담당시킬 수 있다.

위와 같은 방식은 직접적인 통합방식이지만, 메세지 큐를 통한 간접 통합 방식을 사용해도 된다.

메세지 큐를 이용한 간접 통합 방식은 어떤 도메인 관점에서 모델을 사용하느냐에 따라 구현 코드가 달라진다.

따라서, 그 부분에 대해 팀 간 협의와 도메인에 대한 올바른 지식이 필요하다.

### 바운디드 컨텍스트 간 관계

바운디드 컨텍스트는 어떤 식으로든 연결되기 때문에 두 바운디드 컨텍스트는 다양한 방식으로 관계를 맺는다. 두 바운디드 컨텍스트 간 관계 중 가장 흔한 관계는 
한쪽에서 API를 제공하고 다른 한쪽에서 그 API를 호출하는 관계이다. 이러한 관계를 고객/공급자 관계라고 한다.

상류 컴포넌트는 보통 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의하고 이를 공개한다. 예를 들어, 추천 시스템은 하류 컴포넌트가 사용할 수 있는 RestAPI를 제공할 수 있다.
구글의 프로토콜버퍼와 같은 것을 이용해서 서비스를 제공할 수도 있다. 상류 팀의 고객인 하류 팀이 다수 존재하면 상류 팀은 여러 하류 팀의 요구사항을 수용할 수 있는
API를 만들고 이를 서비스 형태로 공개해서 서비스의 일관성을 유지할 수 있다. 이런 서비스를 가리켜 공개 호스트 서비스(OPEN HOST SERVICE)라고 한다.

공개 호스트 서비스의 대표적인 예가 검색이다. 블로그, 카페, 게시판과 같은 서비스를 제공하는 포탈 사이트는 각 서비스 별로 검색 기능을 구현하기보다는 검색을 위한 전용 시스템을 구축하고 검색 시스템과 각 서비스를 통합한다.
이때, 검색 서비스는 상류 컴포넌트가 되고 블로그, 카페, 게시판은 하류 컴포넌트가 된다. 

바운디드 컨텍스트 통합에서 각 바운디드 컨텍스트 별 데이터를 변환하는 일을 담당하는 클래스를 안티코럽션 계층(Anticorruption Layer)이라고 한다.
이 계층에서 두 바운디드 컨텍스트 간의 모델 변환을 처리해 주기 때문에 다른 바운디드 컨텍스트에 영향을 받지 않고 내 도메인 모델을 유지할 수 있다.

두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있다. 예를 들어, 운영자를 위한 주문 관리 도구를 개발하는 팀과 고객을 위한 주문 서비스를 개발하는 팀이 다르다고 가정하자. 이 경우, 두 팀은
주문을 표현하는 모델을 공유함으로써 주문과 관련된 중복 개발을 막을 수 있다. 이렇게 두 팀이 공유하는 모델을 공유 커널이라고 부른다.

공유 커널의 장점은 중복을 줄여준다는 것이다. 두 팀이 하나의 모델을 개발해서 공유하기 때문에 두 팀에서 동일한 모델을 두 번 개발하는 중복을 피할 수 있다. 하지만, 두 팀이 한 모델을
공유하기 때문에 한 팀에서 임의적으로 모델을 변경해서는 안되며 두 팀이 밀접한 관계를 유지해야 한다. 두 팀이 밀접한 관계를 유지할 수 없다면, 공유 커널을 사용할 때의 장점보다는
공유 커널로 인해 개발이 지연되고 정체되는 문제가 더 커지게 된다.

두 바운디드 컨텍스트 간 통합하지 않는 관계를 독립 방식 관계라고 한다. 독립적으로 모델을 관리할 수 있기 때문에 좋다.
다만, 서비스가 커질 경우 독립적인 두 바운디드 컨텍스트를 통합할 시스템을 개발해야 하기 때문에 결국 통합을 해야 할 수밖에 없다.

### 도메인 이벤트

쇼핑몰 서비스에서 구매를 취소하면 환불을 처리해야 한다. 이때 환불 기능을 실행하는 주체는 주문 도메인 엔티티가 될 수 있다. 도메인 객체에서 환불 기능을 실행하려면
환불 기능을 제공하는 도메인 서비스를 파라미터로 전달받고 취소 도메인 기능에서 도메인 서비스를 실행하게 된다.

```java
public class Order{
    // 외부 서비스를 실행하기 위해 도메인 서비스를 파라미터로 전달받음
    public void cancel(RefundService refundService) {
        verifyNotYetShipped();
        this.state = OrderState.CANCELED;
        
        this.refundStatus = State.REFUND_STARTED;
        try {
            refundService.refund(getPaymentId());
            this.refundStatus = State.REFUND_COMPLETED;
        } catch (Exception e){
            ???
        }
    }
}
```

응용 서비스에서 환불 기능을 실행할 수도 있다.
```java
public class CancelOrderService{
    private RefundService refundService;

    @Transactional
    public void cancel(Long orderId) {
        Order order = findOrder(orderId);
        order.cancel();
        
        order.refundStarted();
        try {
            refundService.refund(getPaymentId());
            order.refundCompleted();
        } catch (Exception e){
            ???
        }
    }    
}
```
보통 결제 시스템은 외부에 존재하므로 RefundService는 외부의 환불 시스템 서비스를 호출하는데, 이 때 두가지 문제가 발생한다.
첫 번째 문제는 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야 할지 애매하다는 것이다. 환불 기능을 실행하는 과정에서 익셉션이 발생하면
트랜잭션을 롤백해야 할까? 아니면 일단 커밋해야 할까?

외부의 환불 서비스를 실행하는 과정에서 익셉션이 발생하면 환불에 실패했으므로 주문 취소 트랜잭션을 롤백하는 것이 맞는 것으로 보인다. 하지만,
반드시 트랜잭션을 롤백해야 하는 것은 아니다. 주문은 취소 상태로 변경하고 환불만 나중에 다시 시도하는 방식으로 처리할 수도 있다.

두 번째 문제는 성능에 대한 것이다. 환불을 처리하는 외부 시스템의 응답 시간이 길어지면 그만큼 대기시간이 발생한다. 환불 처리 기능이 30초가 걸리면
주문 취소 기능은 30초만큼 대기 시간이 증가한다. 즉, 외부 서비스 성능에 직접적인 영향을 받는 문제가 있다.

두가지 문제 외에도 도메인 객체에 서비스를 전달하면 설계상 오류가 발생할 수 있다. 주문 엔티티는 주문을 담당해야 하는데, 주문 로직과 결제 로직이 섞이는 문제가 
있다.

도메인 객체에 서비스를 전달할 때 또 다른 문제는 기능을 추가할 때 발생한다. 만약 주문을 취소한 뒤에 환불뿐만 아니라 취소했다는 내용을
통지해야 한다면 어떻게 될까? 환불 도메인 서비스와 동일하게 파라미터로 통지 서비스를 받도록 구현하면 앞서 언급한 로직이 섞이는 문제가 더 커지고 트랜잭션 처리가
더 복잡해진다. 

지금까지 언급한 문제는 바운디드 컨텍스트 간 강한 결합때문이다. 이런 강한 결합을 없애려면 이벤트를 사용해야 한다.

### 이벤트 관련 구성요소

도메인 모델에 이벤트를 도입하려면 세 개의 구성요소를 구현해야 한다.

이벤트 생성 주체 -> 이벤트 디스패처 -> 이벤트 핸들러

이벤트 생성 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다.

이벤트 핸들러는 이벤트 생성 주체가 발생한 이벤트에 응답한다. 이벤트 핸들러는 이벤트 생성 주체가 발생한 이벤트를 전달받아
이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.

이벤트 생성 주체와 이벤트 핸들러를 연결해 주는 것이 이벤트 디스패처이다. 

이벤트의 구성
- 이벤트 종류: 클래스 이름으로 이벤트 종류를 표현
- 이벤트 발생 시간
- 추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

### 이벤트 장점

이벤트를 사용하면 서로 다른 도메인 로직이 섞이는 것을 방지한다. 또한 기능 확장에도 용이하다.

Order -> Event Dispatcher -> OrderCanceled(Event Handler) -> 환불 처리

Order -> Event Dispatcher -> EmailSend(Event Handler) -> 이메일 통지 처리


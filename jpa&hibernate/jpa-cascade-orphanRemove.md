## JPA Cascade + orphanRemoval 

영속성의 전이를 통해 부모 엔티티에서 자식 엔티티까지 한꺼번에 CRUD 작업을 할 수
있게 해주는 것이 cascade옵션이다.

부모 엔티티의 참조가 끊어질 경우, 연관된 자식 엔티티를 자동으로 삭제해주는 고아 객체라는 개념이
있는데, 이것이 바로 orphanRemoval 옵션이다.

프로젝트를 진행하면서 부모 엔티티와 자식 엔티티를 일대다 다대일의 양방향 연관관계로 만들어주었다.
양방향으로 만들고, 부모 엔티티에서 자식 엔티티를 CRUD하기 위해 컬렉션을 통해 연결한 구조이다.

이때, 부모 엔티티에서 @OneToMany옵션으로 cascade.ALL과 orphanRemoval = true 옵션을 주었다.

문제는 부모 엔티티에서 자식 엔티티를 삭제하기 위해서 아래와 같은 코드를 작성했다.
```java
parent.getChildren.remove(child);
```

내가 원하는 동작은 부모 엔티티를 삭제하면, 자식 엔티티도 같이 삭제쿼리가 날라가는 것이었다.

그런데 실제 쿼리를 확인한 결과 부모 엔티티만 삭제되었고, 연관된 자식 엔티티가 삭제되지 않았다.

정확히는 연관된 자식 엔티티의 부모 fk값이 null로 바뀌어 있었다.

여러가지 문서와 검색을 활용한 결과 JPA가 한 행동이 정확히 동작했다고 한다. 그렇다면 내가 원하는 결과는 왜 발생하지 않은 것인가?

stackOverFlow에서 말하길 JPA가 컬렉션에서 삭제해야 하는지 여부를 실제로 알지 못하기 때문이라고 한다.

이것을 객체 모델링 용어로 구성과 집계의 차이점? 이라고 한다는데, 구성에서는 자식 엔티티는 부모 엔티티 없이는 절대 존재할 수 없다라고 한다.

내가 원하는 동작이 이루어지려면 벤더별 확장을 고려하거나, 명시적으로 자식 엔티티를 먼저 지우고 부모 컬렉션에서 제거해야 한다고 한다.

## Hibernate TODO

https://www.whiteship.me/cascade-delete-eb-a5-bc--ec-a0-81-ec-9a-a9-ed-95-98-eb-a0-a4-eb-a9-b4-session-deleteobject-eb-a5-bc--ec-82-ac-ec-9a-a9-ed-95-98-ec-84-b8-ec-9a-94/
- 웹 브라우저에 url을 입력 시 일어나는 일
  - 브라우저의 URL 파싱
    - 어떤 프로토콜을 사용하는지
    - 어떤 URL로 요청할 것인지
    - 어떤 포트로 요청할 것인지
  - "https://www.naver.com" 인 경우
  - https 프로토콜, www.naver.com(URL), https는 기본적으로 443 포트
- https인 경우 HSTS 목록 조회하여 http 요청이여도 https로 요청해준다.
- url host를 DNS 서버에 요청하여 IP주소를 받는다.
- 라우터를 통해 해당 서버의 게이트웨이까지 이동 
- ARP를 통해 논리적 주소인 IP를 컴퓨터의 물리적 주소인 MAC 주소로 변환
- 대상 서버와 TCP 소켓 연결
  - 3-way-handshake 과정을 통해 논리적 연결
  - https 요청인 경우 TLS handshake 과정 추가.
- HTTP 요청 메세지를 서버에 전달
- 서버에서 HTTP 응답을 브라우저로 전달

- 웹 브라우저에 url을 입력 시 일어나는 일
  - 도메인을 찾아가는 절차를 아는가?
  - 서버의 분산 환경에 대한 이해가 있는가?
  - 웹 서버, WAS, 저장소에 대한 이해가 있는가?
  - 브라우저에서 화면을 구성하는 순서와 절차를 아는가?

- WAS란 
  - 웹을 위한 연결, 프로그래밍 언어, 데이터베이스 연동과 같이 애플리케이션을 구현하는데 필요한 기능을 제공하는 서버 프로그램.
  - 웹 브라우저로부터 요청이 들어오면 알맞은 프로그램을 찾아 실행하고, 프로그램의 실행 결과를 응답으로 반환.

요청 파라미터 인코딩
- 웹 브라우저는 웹 서버에 파라미터를 전송할 때 알맞은 charset을 사용하여 파라미터 값을 인코딩한다. 반대로 웹 서버는 알맞은 charset을 사용하여 웹 브라우저가 전송한 파라미터 데이터를 디코딩한다. 
- 예를 들어, 웹 브라우저가 utf-8 인코딩을 하였다면, 서버에서도 동일한 utf-8 디코딩을 해야 데이터를 올바르게 읽을 수 있다.
- POST 방식은 입력 폼을 보여주는 응답 화면이 사용하는 charset을 사용한다. 예를 들어, 응답 결과에서 사용한 charset이 utf-8이면 utf-8을 이용해서 파라미터 값을 인코딩한다. 
- JSP에서는 인코딩 메서드를 사용하지 않는다면, 기본 값으로 ISO-8859-1 charset을 사용한다.
- GET 방식 파라미터 전송 시 인코딩 결정 규칙
  - <a> 태그의 링크 태그에 쿼리 문자열 추가 (웹 페이지 인코딩 사용)
  - HTML Form의 method 속성을 GET으로 지정하여 폼 전송 (웹 페이지 인코딩 사용)
  - 웹 브라우저의 주소창에 직접 쿼리 문자열을 포함하는 url 입력 (브라우저 마다 다름)

캐시란
- 캐시는 동일한 데이터를 중복해서 로딩하지 않도록 할 때 사용한다.
- 웹 브라우저는 첫 번째 요청 시 응답 결과를 로컬 PC의 임시 보관소인 캐시에 저장한다.
- 이후 동일한 URL에 대한 요청이 있으면 WAS에 접근하지 않고 로컬 PC에 저장된 응답 결과를 사용한다.
- 변경이 발생하지 않는, JSP 응답 결과나 이미지, 정적인 HTML 등은 캐시에 보관함으로써 웹 브라우저 응답 속도를 향상시킬 수 있다.

WAS는 JSP 페이지에 대한 요청이 들어오면 다음과 같은 처리를 한다.
- JSP에 해당하는 서블릿이 존재하지 않는 경우
  1. JSP 페이지로부터 자바 코드를 생성한다. (JSP는 HttpJspBase를 상속받은 클래스로써 항상 자바 코드가 생성됨.)
  2. 자바 코드를 컴파일해서 서블릿 클래스를 생성한다. (HttpJspBase extends HttpServlet)
  3. 서블릿에 클라이언트 요청을 전달
  4. 서블릿이 요청을 처리한 결과를 응답으로 생성
  5. 응답을 웹 브라우저에 전송
- JSP에 해당하는 서블릿이 존재하는 경우
  1. 서블릿에 클라이언트 요청을 전달
  2. 서블릿이 요청을 처리한 결과를 응답으로 생성
  3. 응답을 웹 브라우저에 전송
- JSP 페이지를 요청할 때는 JSP를 직접 실행하는 것이 아닌, JSP를 자바 소스 코드로 변환한 뒤 컴파일하여 서블릿을 생성하여 실행.

쿠키
- 쿠키는 웹 브라우저가 보관하는 데이터
- 쿠키 동작 방식
  - 쿠키 생성 : 쿠키를 사용하려면 쿠키를 생성해야 한다. 클라이언트 - 서버 모델에서는 서버가 쿠키를 생성한다. 생성한 쿠키를 HTTP 응답 헤더에 저장해서 웹 브라우저에 전송한다.
  - 쿠키 저장 : 웹 브라우저는 응답 데이터에 포함된 쿠키를 쿠키 저장소에 보관한다. 쿠키의 종류에 따라 메모리나 파일에 저장한다.
  - 쿠키 전송 : 웹 브라우저는 저장한 쿠키를 요청이 있을 때마다 웹 서버에 전송한다. 서버는 브라우저가 전송한 쿠키를 사용하여 필요한 작업을 수행한다.
- 쿠키 구성 요소
  - 이름(쿠키를 구별하는 데 사용하는 이름), 값(쿠키의 이름과 관련된 값), 유효시간(쿠키 유지 시간), 도메인(쿠키를 전송할 도메인), 경로(쿠키를 전송할 요청 경로)
  - 쿠키는 별도의 유효시간을 지정하지 않는다면, 브라우저가 종료될 때 함께 삭제된다. 
  - 쿠키는 지정한 도메인이나 경로로만 쿠키를 전송하도록 제한할 수 있다.
- 웹 브라우저가 타 도메인으로 지정한 쿠키를 받지 않는 이유는 보안 문제 때문
  - 웹 브라우저는 현재 서버의 도메인과 다른 도메인에 대한 쿠키 생성은 허용하지 않는다.

세션
- 세션은 서버에만 생성, 주로 인증 정보 유지를 위해 사용
- 세션은 여러 서버에서 공유가 불가능
- 세션 클러스터링
  - 로그인을 구현할 때, 쿠키와 세션을 사용하면서 가용성을 확보하려면 여러 방법이 있지만 세션 스토리지를 사용해야 한다.
  - 하나의 중개 서버(nginx)와 여러 개의 애플리케이션 서버로 구성되어 있는 아키텍처에서 가용성을 확보하는 방법
    - 세션 객체는 key-value 형태로 저장되기 때문에 인 메모리 솔루션인 redis를 세션 스토리지로 사용
    - redis는 read 성능 및 메모리 사용 효율이 좋기 때문에 memcached 보다 로그인 세션 구현 측면에서 타당함
    - redis는 스프링에서 api를 psa를 사용하여 추상화해 제공

JDBC 프로그램의 실행 순서
1. JDBC 드라이버 로딩
2. 데이터베이스 커넥션 로딩
3. 쿼리 실행을 위한 Statement 생성
4. 쿼리 실행
5. 쿼리 실행 결과 사용
6. Statement 종료
7. 데이터베이스 커넥션 종료

- Class.forName 메소드는 어떤 역할을 할까
  - FQCN(Fully Qualified Class Name)을 인자로 입력하면, 해당 클래스의 클래스 메타 정보를 가진 Class 타입의 객체를 생성
  - JDBC 드라이버에 해당하는 클래스들은 Class.forName 메서드를 통해서 로딩될 때 자동으로 JDBC 드라이버로 등록된다.
- Statement vs PrepareStatement (성능, 보안 측면 차이)
  - 먼저, Statement는 문자열 기반의 SQL 쿼리를 실행하는데 사용되며 PreparedStatement는 매개변수화된 SQL 쿼리를 실행하는데 사용된다.
  - 성능
    - Statement와 PreparedStatement의 가장 큰 차이점은 캐시 사용 여부
      1. 쿼리 문장 분석
      2. 컴파일
      3. 실행
    - Statement는 매번 쿼리를 수행할 때마다, 1~3 단계를 거치게 되고, PreparedStatement는 처음 한번만 단계를 거친 후 캐시에 담아 재사용한다.
  - 보안
    - Statement의 경우 SQL Injection에 취약합니다.
    - PreparedStatement는 SQL Injection에 안전.
- 커넥션 풀은 왜 쓰는 걸까
  - DB와 네트워크 연결하는 시간 단축 -> 응답 시간이 단축 -> 처리량 증가
  - 커넥션 개수를 일정하게 유지하면 -> DB 포화 방지 -> 일관된 DB 성능 유지가 가능
- 커넥션 맺는 건 왜 느릴까
  - 아래와 같은 작업을 사용자가 요청할 때마다 반복해야 한다면, 커넥션을 맺는 작업이 느려질 수밖에 없다.
    - DB 서버 접속을 위해 JDBC 드라이버 로딩
    - DB 접속 정보와 DriverManager.getConnection() 메서드를 통해 DB Connection 객체를 얻는다
    - Connection 객체로부터 쿼리를 수행하기 위한 PreparedStatement를 받는다
    - executeQuery()를 수행하여 그 결과로 ResultSet 객체를 받아 데이터 처리
    - 처리가 정상적으로 완료되면 처리에 사용된 리소스들을 close하여 반환
- 커넥션 풀의 갯수를 많이 지정할 경우 어떤 이슈가 발생할까?
  - 요청이 많이 들어오는 환경이라면 풀의 갯수를 늘린 만큼 더 많은 요청을 처리할 수 있다.
  - 하지만 사용자가 적어서 사용 중인 커넥션이 몇개 없다면, 메모리를 그만큼 점유하는 것이므로 불필요한 메모리가 낭비된다.
- Thread pool 사용하는 이유
  - Thread의 생성과 소멸에 필요한 많은 자원 소비를 줄이기 위해서. 이외에도 Pool 내 최대 Thread 수를 제한할 수 있기 때문에 애플리케이션 오류에 의해 발생할 수 있는 과다한 Thread 생성을 방지하고, 처리 가능한 수 이상의 요청 유입을 방지할 수 있다.
- 톰캣 기본 스레드 개수
  - Tomcat 9 버전 기준 최소 스레드의 수는 25개 최대는 200개이다.

서블릿의 초기화 작업이 필요하다면, loadOnStartUp을 1로 설정하여 요청이 들어와서 처음 서블릿을 사용하는 시점이 아닌 웹 컨테이너인 톰캣을 구동하는 시점에 초기화를 진행해야 성능 상 이점이 있다.

필터란
- 필터는 HTTP 요청과 응답을 변경할 수 있는 재사용 가능한 클래스이다. 
- 필터 적용 지점 옵션
  - REQUEST : 클라이언트 요청인 경우 필터 적용(기본값)
  - FORWARD : forward()를 통해서 제어 흐름을 이동하는 경우 필터 적용
  - INCLUDE : include()를 통해서 포함되는 경우 필터 적용

서블릿컨택스트리스너
- 웹 애플리케이션 컨테이너가 시작되거나, 종료되는 시점에 적절한 초기화를 할 수 있도록 만들어진 클래스


- 스프링 다이나믹 프록시
  - JDK Dynamic Proxy는 interface 기반 프록시
- Weaving
- Compile time weaving, Load time weaving
- 트랜잭션 격리 레벨
- 트랜잭션 전파
- TransactionManager 의 역할
- read only transaction의 이점
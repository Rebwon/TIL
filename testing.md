## test와 관련하여 정리.

### 테스트 메서드의 작성 방식

- 테스트 대상 메서드와 이름을 1:1로 일치
  - 장점: 테스트 메서드의 숫자가 적어져서 보기가 편하고, 대상이 되는 클래스의 메서드와 1:1로 연관지어
  생각할 수 있다.
  - 단점: 추가적인 테스트 케이스가 하나의 테스트 메서드 내에 전부 존재하게 만들 경우, 메서드 내의 초반 테스트 단정문이
  실패하면, 뒤쪽 테스트 케이스들은 실행되지 않는다. 이럴 경우 성공하는 케이스와 실패하는 케이스가 섞여서 구별하기 어렵다.
  
- 테스트 대상 메서드의 이름 뒤에 추가적인 정보를 기재
  - 장점: 더 다양한 케이스 별로 성공/실패를 알 수 있다. 케이스마다 독립적으로 수행할 수 있어 오류의 가능성이 좀 더 줄어든다.
  - 단점: 테스트 케이스만큼 메서드를 만들기 때문에 메서드 숫자가 많아진다. 테스트 메서드 이름을 짓는 데 상당한 요령이 필요하다. 케이스마다
  리소스 초기화(Setup) 작업이 필요하다.
  
- 테스트 시나리오에 집중
  - 장점: 테스트 케이스를 시나리오에 따라 체계적으로 작성할 수 있다. 테스트 클래스를 하나의 업무단위 테스트 단위처럼 문서화할 수 있다.
  - 단점: 테스트 대상 클래스의 단위 메서드 구현 시에 사용하기에는 다소 무리가 따른다.
  
### 테스트 케이스 작성

- 해피데이 시나리오 방식:
정상적인 흐름일 때 동작해야 하는 결과값을 선정해놓는 방식이다.
- 블루데이 시나리오 방식:
발생할 수 있는 예외나 에러 상황에 대한 결과값을 적은 방식이다.

무엇을 테스트 할 것인가? 에 대한 질문

- 결과가 옳은가?
- 모든 경계조건이 옳은가?
- 역(inverse)관계를 확인할 수 있는가?
- 다른 수단을 사용해서 결과를 교차확인할 수 있는가?
- 에러 조건을 강제로 만들어낼 수 있는가?
- 성능이 한도 내에 있는가?

### TDD의 한계

- 동시성 문제:
동시성이 걸려 있는 코드에 대한 테스트는 무결하게 유지하기 어렵다. 상식적으로 파악하기 어려운 불규칙한 문제가
적지 않게 발생하기 때문이다.
- 접근제한자(private/protected 메서드):
private으로 되어 있는 메서드는 일반적인 방법으로는 테스트가 불가능하다. private 메서드와 관련하여 테스트 메서드 필요성 자체에 대한
논의가 필요하다. 현재는 'public으로 되어 있는 메서드만 테스트해도 무방하다'라는 경향이 대세인 것으로 보인다. 왜냐하면 private 메서드는 public메서드들이
사용하는 메서드들이고, public메서드가 테스트 될때 private 메서드들도 함께 테스트가 이뤄진다고 보기 때문이다. 다만, 경우에 따라 우선은 모든 메서드를 public으로 만들어서 테스트가 끝난 다음,
차후에 판단하여 public을 private으로 바꾸는 식의 범위를 줄이는 형태로 접근하는 것도 한 가지 방법이다. 그럴 때에 기존에 생성항 테스트 케이스는 지우지 말고 주석 형태로
남겨놓을 것을 권장한다.
- 의존성 모듈 테스트(target A but A -> B):
테스트하려는 부분에 의존성이 있는 모듈을 사용하고 있는 경우의 테스트도 종종 문제가 된다. 즉, '테스트의 대상이 되는 A가 기타 메서드나 클래스를 참조하고 있을 경우, 그리고 해당
참조 부분에 대한 접근이 쉽지 않을 경우에 B는 어떻게 할 것인가?'라는 문제다. B가 아무런 문제 없이 확실한 모듈이라면 상관없는데, 그렇지 않다면 문제의 소지가 있는 부분이다.
이럴 때는, B를 둘러싼 일종의 프록시 클래스를 하나 만들어서 온전히 B부터 테스트하는 방식으로 접근하는 방식을 취하든가, 아니면 B를 신뢰한다는 가정하에서 A만을 테스트한다. 보통은, 개발자의 성향상 후자를 많이 선택한다.
근래에는 의존성 제거를 위해서 Mock 객체를 많이 사용한다.

### Mock 작업

언제 Mock 객체를 만들 것인가?

1. 테스트 작성을 위한 환경 구축이 어려워서
   - 환경 구축을 위한 작업 시간이 많이 필요한 경우에 Mock 객체를 사용한다.
   - 경우에 따라서는 특정 모듈을 아직 갖고 있지 않아서 테스트 환경을 구축하지 못할 수도 있다.
   - 타 부서와의 협의나 정책이 필요한 경우에도 Mock이 필요하다.

2. 테스트가 특정 경우나 순간에 의존적이라서
   - 특정한 경우에 의존적으로 동작하는 기능들이 있다. 이런 경우는 특히 예외처리를 테스트할때 많이 접하게 된다. 

3. 테스트 시간이 오래 걸려서
   - 테스트 케이스의 실행시간 단축을 위해 Mock이 사용될 때도 있다. 특정한 모듈을 호출했을 때, 속칭 멀리 갔다 오느라 시간이 걸리는 경우가 있다.
   이럴 때는 보통 시간이 오래 걸리는 구간이나 모듈을 Mock으로 통쨰로 대체해서 만든다. 물론 이 경우 Mock으로 대체하는 부분은 신뢰도 높은 모듈이란
   가정이 선행돼야 한다. 아니면 Mock 대체 모듈에 대해서는 다른 부분에서 반드시 테스트할 수 있어야 한다.
   
### Dummy 객체

더미 객체는, 단지 인스턴스화된 객체가 필요할 뿐 해당 객체의 기능까지는 필요하지 않은 경우에 사용한다. 따라서 해당 더미 객체의 메서드가 호출될 때 정상 동작은 보장되지
않는다. 일부 개발자는 더미 객체의 메서드는 호출을 가정하고 만들어진 것이 아니기 때문에, 만일 호출 시엔 예외를 발생시키게 만들어놓아야 한다고 말한다.

용어 정리
- 스텁과 더미의 차이 
  - 단지 인스턴화될 수 있는 수준의 객체라면 더미
  - 인스턴스화된 객체가 특정 상태나 모습을 대표하면 스텁  

### 개발 영역에 따른 TDD 작성 패턴

#### 생성자 테스트

- 단순히 클래스를 생성한다는 의미를 갖는 생성자는 굳이 테스트 케이스를 작성하지 않는다.
다만, 객체 사용을 위해 반드시 갖춰야 하는 값을 생성자에 설정하는 경우는 필요에 따라 테스트를 작성한다.
- 단, 가끔 생성자에서 객체 생성의 의미뿐 아니라, 선행조건이나 업무로직을 직접 기술하는 경우도 있는데, 이럴 경우 테스트를
작성해야 한다. (일반적으로 좋은 애플리케이션이라면, 생성자의 파라미터로 지정된 값 외의 항목을 이용하는 코드를 생성자 메서드 안에 넣지
않는다. 자칫, 외견상 파악할 수 없는 숨겨진 로직이 되어서 모듈 자체의 복잡도를 높이기 때문이다.)

#### DTO 스타일의 객체 테스트

- 클래스가 속성 필드와 단순 setter/getter로만 이뤄진 DTO 스타일로 만들어진 경우에는 굳이 테스트 케이스를 작성하지 않는다.
- 단, 특정한 목적을 갖고 만들어진 불변 객체의 경우에는 getter 계열 메서드나 상태를 확인할 수 있는 is 계열(isReady, isStatus 등)의
메서드를 이용한 테스트 케이스를 작성하기도 한다.

#### 닭과 달걀 메서드 테스트

- 메서드가 서로 맞물려 있어서, 완전히 하나만 독립적으로 테스트하기 어려운 경우가 있다. 보통 로직 메서드(add, remove, set 계열 메서드)와 상태 확인 메서드
(get, show, is 계열 메서드)가 짝을 이루는 경우에 해당한다. 이럴 경우엔 어느 한쪽의 테스트 케이스를 먼저 만들기 어렵다. 이를테면 구매자 목록을 관리하는 클래스가
있다고 가정해보자. 테스트 케이스로 작성해야 하는 메서드는 다음과 같다.

Customer 클래스

|메서드명|설명|
|---|------|
|void add(String name)|구매자 목록에 이름을 추가한다.|
|String get(int order)|해당 번째(order)로 등록된 구매자의 이름을 보여준다.|

아래는 테스트 코드이다.

```java
public class CustomerTest{
    @Test
    void testAdd() throws Exception{    // 1
        Customer customer = new Customer();
        customer.add("김철수");        // 2
        assertThat(customer.get(1)).isEqualTo("김철수");   // 3
    }

    @Test
    void testGet() throws Exception{
        Customer customer = new Customer();
        customer.add("김철수");
        assertThat(customer.get(1)).isEqualTo("김철수");
    }
}
```

1. 구매자를 추가하는 add 메서드에 대한 테스트 케이스 작성을 시작한다

2. '김철수'라는 구매자를 추가한다.

3. 시나리오의 흐름상 구매자가 올바르게 추가되었는지 확인하려면 get메서드를 호출해야 하는데 아직 만들어지지 않은 상태이다. get 메서드가 선행적으로
구현되어 있어야 add 메서드 구현을 위한 테스트 케이스 작성이 가능하다는 사실을 알게 된다.

반대의 경우도 같다. get메서드를 테스트하기 위해서는 add메서드의 구현이 선행되어야 한다.

위의 두 테스트 케이스는 어느 한쪽만 먼저 구현하기가 어려운 상황을 보여주는 예이다. 서로가 상호 의존적으로 테스트 케이스 작성에 참여하는 형태이다.
좋은 테스트 케이스 작성법 중 하나는 *한 번에 실패하는 테스트 케이스 하나씩 작성*하는 것이다. 현 상황은, 그 규칙을 지키기 어려운 상태이다. 이런 상황에서 택할 수 있는 방법은
아래와 같다.

- 실패하는 테스트 케이스가 두 개인 상태에서 작업하기(일반적 방법) : 위와 같은 테스트 케이스는 난이도가 낮아서 두 개의 실패하는 테스트를 놓고 작업하기가 어렵지 않다.
하지만 각각 쉽지 않은 난이도의 메서드이고, 작성 도중 실패가 계속된다면, 어느 쪽 문제로 테스트가 실패하는지 파악하기 어려울 수 있다.

- 안정성이 검증된 제3의 모듈을 사용하기(가능만 하다면, 권장) : 검증은 다른 모듈로 할 수 있다. 굳이 외부 모듈이 아니더라도, 이미 검증된 다른 메서드를 사용해 검증할 수 있다면 해당 메서드를 사용한다.

- 자바 리플렉션을 이용해 강제로 확인하기(대체적으로 비권장) : 자바 리플렉션을 이용한 방식은, 어쩔 수 없는 한정된 상황일 경우에 사용한다.

#### 객체 동치성 테스트

- 내부 상태(보통은 필드값)를 직접 꺼내와서 각각 비교한다.
- toString을 중첩구현해놓고, toString 값으로 비교한다.
- equals 메서드를 중첩구현한다.
- Unitils의 assertReflectionEquals를 이용한다.

#### 컬렉션 테스트

- 자바 기본형이나 String이 컬렉션에 들어 있는 경우 : 
이런 경우엔 곧바로 비교가 가능하다. 기본적으로 컬렉션들은 안에 담겨 있는 객체들의 toString 값을 열거 형태로 출력하게 되어 있다.

- 일반 객체가 컬렉션에 들어 있는 경우 :
일반 객체에 toString을 구현하고, 컬렉션 객체를 비교할때 toString을 사용하여 비교한다.

#### 웹 애플리케이션에 대한 TDD 접근 전략 정리

- 모델과 뷰와 컨트롤러를 최대한 분리시킨다.
- 뷰는 단순히 표현 계층으로 보고 업무로직이 들어가지 않도록 유지한다.
- 뷰에 대한 TDD는 ROI를 잘 따져보고, 필요하다면 TDD를 포기하고 Record & Play 방식의 툴을 사용해 기능 테스트나 회귀 테스트의 비용을 줄이는 쪽으로
생산성을 높이자.
- 컨트롤러가 프레임워크 차원에서 지원될 때는 굳이 테스트 케이스를 만들려고 하지 않는다. (단, RestDocs의 경우는 해야함.)
- 모델에 대한 TDD는 최대한으로 적용한다.

### TDD 유의사항

- 테스트 케이스는 이름이 중요하다. 로직을 살피지 않고 메서드 이름만으로 충분희 의미를 전달할 수 있을 정도로 작성하는 것이 중요하다.
- 더 이상 제대로 동작하지 않는 테스트 케이스는 제거한다.
- TDD는 자동화된 테스트를 만드는 것이 최종 목표가 아니다.
- 모든 상황에 대한 테스트 케이스를 만들 필요는 없다.
- 여러 개의 실패하는 테스트 케이스를 한 번에 만들지 않는다.
- 하나의 테스트 케이스는 하나만 테스트하도록 작성한다.
- 전통적인 테스트 기법을 배워두자.
- 테스트 케이스는 최대한 고립시킨다. (테스트 케이스가 없는 다른 모듈, 데이터베이스 연동, 외부 시스템, 콘솔 출력, 네트워크는 테스트에 들어가지 않도록 하자.)

BDD로 개발할 때, 전체를 관통하는 가장 중요한 질문은 "현재 시스템에 들어 있지 않은 기능 중 가장 먼저 구현되어야 하는 것은 무엇인가?"이다.
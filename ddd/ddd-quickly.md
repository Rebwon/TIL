DDD Quickly

### Entity

Entity의 ID를 생성하는 방법
- ID는 사용자가 볼 수 없도록 모듈에서 자동으로 생성되고 소프트웨어 내부에서 사용될 수 있습니다.
- 이 키(Entity ID)는 데이터베이스 테이블의 기본 키가 될 수 있으며, 이 키는 데이터베이스에서 고유해야 합니다. 데이터베이스에서 개체를 검색할 때마다 ID가 검색되고 메모리에 다시 생성됩니다.
- ID는 공항 고유 식별 번호처럼 사용자가 만들 수 있습니다.
  - 각 공항에는 고유 문자열 ID가 있으며, 이는 전 세계 여행사가 국제적으로 인정하고 여행 일정에서 공항을 식별하기 위해 사용합니다.
- 또 다른 해결 방법은 개체의 속성을 사용하여 ID를 생성하는 것이며, ID가 충분하지 않을 경우 다른 속성을 추가하여 해당 개체를 식별할 수 있습니다.

객체가 특성이 아닌 ID로 구분되는 경우, 모델의 정의에 따라 다음 항목을 기본 항목으로 지정합니다.
- 클래스 정의를 단순하게 유지하고 수명 주기 연속성과 식별에 초점을 맞춥니다.
- 형식이나 내역에 관계없이 각 개체를 구별하는 방법을 정의합니다. 특성별로 개체를 일치시켜야 하는 요구 사항에 주의하십시오.
- 각 개체에 대해 고유한 결과를 생성하도록 보장되는 작업을 정의하십시오. 가능한 경우 고유하게 보장되는 기호를 연결하십시오.
- 이러한 식별 수단은 외부에서 제공되거나 시스템에 의해 생성된 임의의 식별자일 수 있지만, 모델의 ID 구분과 일치해야 합니다.
- 모델은 같은 것이 되는 것이 무엇을 의미하는지 정의해야 합니다.

엔티티는 도메인 모델의 중요한 개체이며 모델링 프로세스의 시작부터 고려되어야 합니다. 
개체가 엔터티여야 하는지 아닌지를 결정하는 것도 중요합니다.

### Value Objects

고객이 엔티티 개체인 경우 특정 은행 클라이언트를 나타내는 이 고객 개체의 인스턴스 하나를 다른 클라이언트에 해당하는 계정 작업에 재사용할 수 없습니다. 결과적으로 모든 클라이언트에 대해 이러한 인스턴스를 만들어야 합니다. 이로 인해 수천 개의 인스턴스를 처리할 때 시스템 성능이 저하될 수 있습니다.

값 개체는 다른 값 개체를 포함할 수 있으며, 엔티티에 대한 참조도 포함할 수 있습니다.
Value Objects는 단순히 도메인 객체의 속성을 포함하는 데 사용되지만, 모든 속성이 포함된 긴 목록을 포함해야 하는 것은 아닙니다. 속성은 서로 다른 개체로 그룹화할 수 있습니다. Value Object를 구성하기 위해 선택한 특성은 개념적 전체를 형성해야 합니다.

### Services

도메인을 분석하고 모델을 구성하는 주요 개체를 정의하려고 하면 도메인의 일부 측면이 개체에 쉽게 매핑되지 않는다는 것을 알게됩니다. 개체는 일반적으로 개체에 의해 관리되는 내부 상태인 속성을 가진 것으로 간주되며 동작을 나타냅니다.

우리가 유비쿼터스 언어를 개발할 때, 도메인의 주요 개념이 언어에 도입되고, 언어의 명사는 쉽게 객체에 매핑됩니다. 해당 명사와 연관된 언어의 동사는 그 사물들의 행동의 일부가 됩니다.

동사는 어떤 물체에 속하지 않는 것처럼 보입니다. 이들은 도메인의 중요한 동작을 나타내므로, 무시되거나 일부 엔티티 또는 값 개체에만 통합될 수 없습니다. 이러한 동작을 객체에 추가하면 객체가 손상되어 객체에 속하지 않는 기능을 나타냅니다. 

예를 들어, 한 계좌에서 다른 계좌로 송금하는 경우, 해당 기능이 송신 계좌에 있어야 합니까? 수신 계좌에 있어야 합니까?

둘중 어느쪽이든 똑같이 잘못된 느낌인거 같습니다.

도메인에서 이러한 동작이 인식되면 이를 서비스로 선언하는 것이 가장 좋습니다. 이러한 개체에는 내부 상태가 없으며, 이 개체의 목적은 단순히 도메인에 대한 기능을 제공하는 것입니다.

서비스는 작업을 제공하는 인터페이스 역할을 합니다. 서비스는 기술 프레임워크에서 일반적이지만 도메인 계층에서도 사용할 수 있습니다. 서비스는 서비스를 수행하는 개체에 대한 것이 아니라 작업을 수행하는 대상 개체와 관련이 있습니다.

서비스는 여러 개체의 연결 지점입니다. 서비스에 기본적으로 속해야만 하는 동작(기능)을 도메인 개체에 포함해서는 안됩니다. 이러한 동작이 도메인 개체에 포함될 경우 해당 기능과 작업의 수혜자인 개체 사이에 강한 결합이 발생합니다. 여러 개체 간의 높은 결합은 코드를 읽고 이해하는데 어렵게 만들고, 코드를 변경하기 어렵게 만들기 때문에 설계가 미흡하다는 신호입니다.

서비스는 일반적으로 도메인 개체에 속하는 작업을 대체해서는 안 됩니다. 필요한 모든 작업에 대해 서비스를 생성해서는 안 됩니다. 그러나 이러한 작업이 도메인에서 중요한 개념으로 부각되면 해당 작업을 위한 서비스를 생성해야 합니다.

서비스에는 세 가지 특성이 있습니다.
1. 서비스에서 수행하는 작업은 자연스럽게 엔티티 또는 값 개체에 속하지 않는 도메인 개념을 나타냅니다.
2. 수행되는 작업은 도메인의 다른 개체를 참조합니다.
3. 작업에 대한 상태를 저장하면 안됩니다.

웹 기반 리포트 프로그램의 예
- 리포트는 데이터베이스에 저장된 데이터를 사용하며 템플릿을 기반으로 생성됩니다.
- 최종 결과는 웹 브라우저에서 사용자에게 표시되는 HTML 페이지입니다.

UI 계층은 웹 페이지에 통합되어 있습니다 사용자가 로그인할 수 있으며 원하는 보고서를 선택하고 버튼을 클릭하여 요청할 수 있습니다.

애플리케이션 계층은 사용자 인터페이스, 도메인 및 인프라 사이에 있는 얇은 계층입니다.
- 로그인 작업 중에 데이터베이스 인프라와 상호 작용합니다.
- 리포트를 생성해야 할 때 도메인 계층과 상호 작용합니다.

도메인 계층에는 도메인의 코어와 리포트와 직접 관련된 개체가 포함됩니다. 이러한 개체 중 두 가지는 리포트와 템플릿입니다. 인프라 계층은 데이터베이스 액세스 및 파일 액세스를 지원합니다. 사용자가 만들 리포트를 선택할 때, 실제로 이름 목록에서 리포트 이름을 선택합니다.

리포터는 문자열 형식의 리포트 ID, 리포트에 표시되는 항목 및 리포트에 포함된 데이터의 시간 간격과 같은 일부 다른 매개변수도 전달됩니다. 리포트 이름은 응용 프로그램 계층을 통해 도메인 계층으로 전달됩니다. 도메인 계층은 이름이 지정된 리포트를 만들고 반환할 책임이 있습니다. 
리포트는 템플릿을 기반으로 하기 때문에 서비스를 만들 수 있으며, 서비스의 목적은 리포트 식별자에 해당하는 템플릿을 얻는 것입니다. 

이 템플릿은 파일이나 데이터베이스에 저장됩니다. 보고서 개체 자체에 이러한 작업을 넣는 것은 적절하지 않습니다. 템플릿 개체에도 속하지 않습니다. 따라서 리포트 식별자를 기반으로 리포트 템플릿을 검색하는 별도의 서비스를 생성합니다. 도메인 계층에 있는 서비스입니다. 파일 인프라를 사용하여 디스크에서 템플릿을 검색합니다.

### Modules

응집에는 몇 가지 유형이 있습니다. 가장 많이 사용되는 두 가지는 통신 응집과 기능 응집입니다.

통신 응집력은 모듈의 일부가 동일한 데이터에서 작동할 때 이루어집니다. 두 모듈 사이에는 강한 관계가 있기 때문에 그룹으로 묶는 것이 타당합니다.

기능 응집력은 모듈의 모든 부분이 함께 작동하여 잘 정의된 작업을 수행할 때 달성됩니다. 이것은 최고의 응집 유형으로 여겨집니다.

모듈에는 다른 모듈이 액세스하는 인터페이스가 잘 정의되어 있어야 합니다.

모듈의 3개 객체를 호출하는 대신 하나의 인터페이스에 액세스하는 것이 좋습니다. 커플링이 감소하기 때문입니다. 커플링이 낮으면 복잡성이 감소하고 유지 보수성이 향상됩니다. 

유비쿼터스 언어의 일부가 되는 모듈 이름을 지정하십시오. 모듈과 모듈의 이름은 도메인에 대한 통찰력을 반영해야 합니다.

### Aggregates

다대다 연결이 있으며 대다수의 연결이 양방향입니다. 이로 인해 복잡성이 증가하고 개체의 수명 주기 관리가 어려워집니다. 연결 수를 최대한 줄여야 합니다. 모델에 필요하지 않은 연관성을 제거해야 합니다. 도메인에는 있을 수 있지만 모델에는 필요하지 않은 경우 삭제하십시오. 제약 조건을 추가하여 다중성을 줄일 수 있습니다. 많은 개체가 관계를 충족하는 경우, 관계에 적절한 제약 조건이 적용되면 한 개체만 해당 관계를 충족할 수 있습니다. 여러 차례로 양방향 연결을 단방향으로 전환가능합니다.

각 차에는 엔진이 있고, 모든 엔진에는 작동하는 자동차가 있습니다. 이 관계는 양방향이지만, 자동차에 엔진이 있고 그 반대는 아니라는 점을 고려하면 쉽게 단순화할 수 있습니다.

개체 간의 연결을 줄이고 단순화해도 여전히 여러 관계가 유지될 수 있습니다. 은행 시스템은 고객 데이터를 보관하고 처리합니다. 이 데이터에는 이름, 주소, 전화 번호, 직무 설명 및 계정 데이터(계좌 번호, 잔액, 수행된 작업 등)와 같은 고객 개인 데이터가 포함됩니다. 시스템이 고객에 대한 정보를 보관하거나 완전히 삭제할 때는 모든 참조가 제거되었는지 확인해야 합니다. 많은 개체에 이러한 참조가 있으면 모든 개체가 제거되었는지 확인하기 어렵습니다. 또한 고객에 대해 일부 데이터가 변경될 경우 시스템은 시스템 전체에서 데이터가 올바르게 업데이트되고 
데이터 무결성이 보장되는지 확인해야 합니다. 이 문제는 일반적으로 데이터베이스 수준에서 해결됩니다. 트랜잭션은 데이터 무결성을 적용하는 데 사용됩니다. 하지만 모델을 세심하게 설계하지 않으면 데이터베이스 경합이 발생하여 성능이 저하됩니다. 데이터베이스 트랜잭션이 이러한 작업에서 중요한 역할을 하지만, 데이터 무결성과 관련된 몇 가지 문제를 모델에서 직접 해결하는 것이 바람직합니다.

Aggregate는 데이터 변경과 관련하여 하나의 단위로 간주되는 연결된 개체 그룹입니다. Aggregate는 내부의 개체와 외부의 개체를 구분하는 경계로 구분됩니다. 각 Aggregate에는 루트가 하나씩 있습니다. 루트는 엔티티이며 외부에서 액세스할 수 있는 유일한 개체입니다. 루트에는 Aggregate 개체에 대한 참조가 포함될 수 있으며 다른 개체에는 서로에 대한 참조가 포함될 수 있지만 외부 개체에는 루트 개체에 대한 참조만 포함될 수 있습니다. 경계 내에 다른 엔티티가 있는 경우 해당 엔티티의 ID는 로컬이며 Aggregate 내부에서만 의미가 있습니다.

작업이 완료된 후 외부 개체가 참조를 보류하지 않는다는 조건으로 루트가 내부 개체의 일시적 참조를 외부 개체로 전달할 수 있습니다. 이를 위한 한 가지 간단한 방법은 Value Object의 복사본을 외부 개체에 전달하는 것입니다. 이러한 개체는 어떠한 방식으로도 Aggregate의 무결성에 영향을 미치지 않으므로 실제로 어떤 일이 발생하든 상관 없습니다.

Aggregate 개체가 데이터베이스에 저장된 경우 쿼리를 통해 루트만 가져올 수 있어야 합니다. 
다른 개체는 traversal associations을 통해 얻어야 합니다. 

traversal associations은 참조를 따라 다른 개체로 이동하는 것. Me가 You를 언급하면 방향은
Me와 You만 왔다 갔다 할 수 있다. 서로에 대한 참조를 유지하는 것으로 양방향이 있을 수 있다.

Aggregate 내의 개체는 다른 Aggregate의 루트에 대한 참조를 포함할 수 있어야 합니다. 루트 엔티티는 글로벌 ID를 가지며 불변성을 유지하는 역할을 합니다. 내부 엔티티에 로컬 ID가 있습니다.

### Factories

엔티티 및 에그리거트는 종종 규모가 크고 복잡할 수 있으며, 루트 엔티티의 생성자에서 생성하기에는 너무 복잡하다. 그것은 마치 프린터가 조립되어서 나오는 것이 아닌 스스로 만들어지게 하는 것과 같다. 

팩토리는 개체 생성에 필요한 지식을 캡슐화하는데 사용되며 Aggregate를 생성하는데 유용하다. Aggregate 루트가 생성되면 Aggregate에 포함된 모든 개체가 생성되고 모든 불변식이 적용된다.

팩토리에서 개체 생성 시 프로세스가 원자성이 되는 것이 중요하다. 그렇지 않으면 일부 개체에 대해 생성 프로세스가 일부만 수행되어 정의되지 않은 상태가 된다. 이는 Aggregate의 경우 더욱 그렇다. Aggregate 루트가 생성되면 불변성의 대상이 되는 모든 개체도 생성해야 한다. 그렇지 않으면 불변성을 적용할 수 없다. 개체를 제대로 생성할 수 없는 경우 예외가 발생하여 잘못된 값이 반환되지 않도록 해야 한다.

팩토리 생성 시 개체의 캡슐화를 위반해야 하므로 주의하여 수행해야 한다. 개체의 변경 사항 중 생성 규칙이나 일부 불변성에 영향을 미치는 사항이 있을때마다 새로운 조건을 지원하도록 팩토리를 업데이트해야 한다.

팩토리는 생성된 개체와 밀접한 연관이 있기 때문에, 그것이 약점이 될 수도 있지만 장점이 될 수도 있다. Aggregate에는 밀접하게 관련된 일련의 개체들이 포함되어 있다. 루트의 구성은 Aggregate에서 다른 개체를 생성하는 것과 관련이 있다. 따라서 Aggregate을 통합하는 논리가 있어야 한다. 이 논리는 다른 개체들의 구조에 관한 것이기 때문에 자연스럽게 어떤 개체에도 속하지 않는다. 따라서 전체 Aggregate을 생성하는 작업이 지정되고 Aggregate을 유효하게 만들기 위해 적용되어야 하는 규칙, 제약조건 및 불변성이 포함된 팩토리를 사용하는 것이 적절해보인다. 팩토리 객체는 단순한 상태를 유지하며, 복잡한 구성 논리의 혼란이 존재하지 않고
Aggregate 개체를 생성한다는 목적에 부합한다.

엔티티 팩토리와 값 개체 팩토리는 다르다. 값 개체는 대부분 불변성을 띄며 필요한 모든 속성을 생성한다. 값 개체를 생성할 때는 유효한 최종 개체여야 한다. 변하면안된다. 엔티티는 불변성을 띄지 않는다. 따라서 나중에 모든 불변성을 만족해야 한다는 일부 속성을 설정하여 변경할 수 있다. 또 다른 차이점은 엔티티에는 ID가 필요한 반면, 값 개체는 ID가 없다.

팩토리가 필요하지 않은 경우가 있으며, 단순 생성자만으로 충분하다. 다음과 같은 경우 생성자를 사용하자.
- 구조가 복잡하지 않다.
- 한 개체의 생성 과정에서 다른 개체는 연관되지 않으며, 필요한 모든 속성은 생성자로 전달 가능하다.
- 클라이언트는 구현에 관심이 있으며, 사용된 전략을 선택할 수 있다.
- 클래스는 타입이다. 관련 계층이 없으므로 구체적인 구현 목록 중 하나를 선택할 필요가 없다. (계층적 구조의 개체
가 아닌 경우를 말함)

팩토리는 새 개체를 처음부터 생성하거나, 이전에 존재했지만 데이터베이스에 유지된 개체를 재구성해야한다. 엔티티를 데이터베이스의 나머지 위치에서 메모리에 다시 가져오려면 새 엔티티를 생성하는 프로세스와는 완전히 다른 프로세스가 필요하다.

### Repository

저장소 구현은 인프라와 유사할 수 있지만 저장소 인터페이스는 순수한 도메인 모델이 될 것입니다.

팩토리와 리포지토리는 관계가 있다. 이 두가지 모두 모델 중심 설계의 패턴이며 도메인 개체의 수명 주기를 관리하는데 도움이 된다. 팩토리는 개체 생성과 관련이 있지만 리포지토리는 이미 존재하는 개체를 관리한다. 리포지토리는 개체를 재구성하므로 팩토리로 표시될 수도 있다.

리포지토리를 팩토리와 혼용해서는 안된다. 리포지토리는 이미 생성된 개체를 찾는 것이고 팩토리는 새 개체를 생성하는 것이다. 리포지토리에 새 개체를 추가할 때는 먼저 팩토리를 사용하여 새 개체를 생성한 다음에 새 개체를 저장할 리포지토리에 제공해야 한다.

팩토리는 순수 도메인이지만 리포지토리는 인프라에 대한 연관이 포함될 수 있다는 점도 유의해야 한다.